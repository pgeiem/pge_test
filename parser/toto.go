
/*
// RecurrentDateList represents a list of RecurrentDate.
type RecurrentDateList []RecurrentDate

func (rlist *RecurrentDateList) Add(pattern string) error {
	r, err := ParseRecurrentDate(pattern)
	if err != ninl {
		return err
	}
	liste = rlist.append(r)
}

// Next returns the next occurrence based on the current time.
func (rlist *RecurrentDateList) Next(now time.Time) time.Time {
	next := time.Date())
	for _, r := range rlist {
		n := r.Next(now)
		if n < next {
			next = n
		}
	}
	return nil
}

// Prev returns the previous occurrence based on the current time.
func (r *RecurrentDateList) Prev(now time.Time) time.Time {
}
*/
/*
// RecurentSegment represents a segment of recurrent dates.
type RecurentSegment struct {
	Recurences RecurrentDateList
	Duration   time.Duration
}

// Between returns the time segments between the given time range.
func (rs *RecurentSegment) Between(from, to time.Time) TimeSegments {
	// unroll the recuruences list and generate the segments
	// do not forget to include one prev if needed
}

// Check if t is included in the recurent segment, this means that t is between the start and the end of one of the segment generated by the recurent date
// This is used for example to enable conditionally some rules depending on date included in a rule
func (rs *RecurentSegment) IsWithin(t time.Time) bool {
}
*/

// Duration represents a duration with second resolution.
type Duration time.Duration

// toDuration converts Duration to time.Duration.
func (d Duration) toDuration() time.Duration {
	return time.Duration(d)
}

// ParseDuration parses a duration string with units: seconds (s), minutes (m), hours (h), days (d), weeks (w).
func ParseDuration(s string) (Duration, error) {
	var totalSeconds int64
	var multipliers = map[byte]int64{
		'w': 7 * 24 * 60 * 60,
		'd': 24 * 60 * 60,
		'h': 60 * 60,
		'm': 60,
		's': 1,
	}

	matches := regexp.MustCompile(`^(\d+w)?(\d+d)?(\d+h)?(\d+m)?(\d+s)?$`).FindStringSubmatch(s)
	if matches == nil || s == "" {
		return 0, fmt.Errorf("error while parsing %s duration, invalid pattern", s)
	}

	for _, match := range matches[1:] {
		if match == "" {
			continue
		}

		num, err := strconv.ParseInt(match[:len(match)-1], 10, 64)
		if err != nil {
			return 0, fmt.Errorf("error while parsing %s duration, invalid number, %s", s, err)
		}

		unit := match[len(match)-1]
		multiplier, exists := multipliers[unit]
		if !exists {
			return 0, fmt.Errorf("error while parsing %s duration, invalid unit (%c)", s, unit)
		}

		totalSeconds += num * multiplier
	}

	return Duration(totalSeconds * int64(time.Second)), nil
}
