package parser

/*
// RecurrentDateList represents a list of RecurrentDate.
type RecurrentDateList []RecurrentDate

func (rlist *RecurrentDateList) Add(pattern string) error {
	r, err := ParseRecurrentDate(pattern)
	if err != ninl {
		return err
	}
	liste = rlist.append(r)
}

// Next returns the next occurrence based on the current time.
func (rlist *RecurrentDateList) Next(now time.Time) time.Time {
	next := time.Date())
	for _, r := range rlist {
		n := r.Next(now)
		if n < next {
			next = n
		}
	}
	return nil
}

// Prev returns the previous occurrence based on the current time.
func (r *RecurrentDateList) Prev(now time.Time) time.Time {
}
*/
/*
// RecurentSegment represents a segment of recurrent dates.
type RecurentSegment struct {
	Recurences RecurrentDateList
	Duration   time.Duration
}

// Between returns the time segments between the given time range.
func (rs *RecurentSegment) Between(from, to time.Time) TimeSegments {
	// unroll the recuruences list and generate the segments
	// do not forget to include one prev if needed
}

// Check if t is included in the recurent segment, this means that t is between the start and the end of one of the segment generated by the recurent date
// This is used for example to enable conditionally some rules depending on date included in a rule
func (rs *RecurentSegment) IsWithin(t time.Time) bool {
}
*/
